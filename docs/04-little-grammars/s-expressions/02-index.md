---
title: "s-expressions"
draft: true
date: 2024-01-01T08:00:00-08:00
---

For example, let us look at the definitions of nodes in the simplest grammar,
`sexp`, and then build up to more complicated nodes like function declarations.

## grammar.js

The whole `grammar.js` is just 52 lines with loads of whitespace.

There are 5 nodes:

| type | named   |
| ---- | ------- |
| sexp | named   |
| list | named   |
| atom | named   |
| `(`  | unnamed |
| `)`  | unnamed |

The complete `grammar.js` reformatted:

```js
const PARENS_LEFT = "("; // Tokens
const PARENS_RIGHT = ")";
const PREC = {}; // Precedences
const delim = (open, x, close) => seq(open, x, close); // Combinators
// Grammar
module.exports = grammar({
  name: "sexp",
  rules: {
    sexp: ($) => $._sexp,
    _sexp: ($) => choice($.atom, $.list),
    atom: ($) => /[_@a-zA-Z0-9\xC0-\xD6\xD8-\xDE\xDF-\xF6\xF8-\xFF:-]+/,
    list: ($) => delim(PARENS_LEFT, repeat($._sexp), PARENS_RIGHT),
  },
});
```

## node-types.json

This generates the following `node-types.json`:

```json
[
  {
    "type": "list",
    "named": true,
    "fields": {},
    "children": {
      "multiple": true,
      "required": false,
      "types": [
        { "type": "atom", "named": true },
        { "type": "list", "named": true }
      ]
    }
  },
  {
    "type": "sexp",
    "named": true,
    "fields": {},
    "children": {
      "multiple": false,
      "required": true,
      "types": [
        { "type": "atom", "named": true },
        { "type": "list", "named": true }
      ]
    }
  },
  {
    "type": "(",
    "named": false
  },
  {
    "type": ")",
    "named": false
  },
  {
    "type": "atom",
    "named": true
  }
]
```

Observations:

- `choice($.atom, $.list)` is encoded as:

  ```js
  "children": {
    "multiple": false,
    "required": true,
    "types": [
      { "type": "atom", "named": true },
      { "type": "list", "named": true }
    ]
  }
  ```

  So, to enforce only one choice, `multiple=flase`, `required=True`.

- `delim(PARENS_LEFT, repeat($._sexp), PARENS_RIGHT)` /
  `repeat(choice($.list,$.atom))` is encoded as:

  ```js
  "children": {
    "multiple": true,
    "required": false,
    "types": [
      { "type": "atom", "named": true },
      { "type": "list", "named": true }
    ]
  }
  ```

  So, multiple children, but none required.

  Not completely sure what is being encoded here.

  This seems to completely discard the `delim` and `PARENS_..` parts, and only
  be a definition of `repeat($_sexp)`, which being a choice, expands to
  `repeat(choice($.list,$.atom))`.

  Guessing that `repeat1(choice($.list,$.atom))` would be the same, but with `required=true`.

## grammar.json

Ok, now lets have a look at the corresponding `grammar.json` to see how it
supplements the information in `node-types.json`, leaving `members` out for
bevity:

```json
{
  "name": "sexp",
  "rules": {
    "sexp": {
      "type": "SYMBOL",
      "name": "_sexp"
    },
    "_sexp": {
      "type": "CHOICE",
      "members": [ ... ]
    },
    "atom": {
      "type": "PATTERN",
      "value": "[_@a-zA-Z0-9\\xC0-\\xD6\\xD8-\\xDE\\xDF-\\xF6\\xF8-\\xFF:-]+"
    },
    "list": {
      "type": "SEQ",
      "members": [ ... ]
    }
  },
  "extras": [ { "type": "PATTERN", "value": "\\s" } ],
  "conflicts": [],
  "externals": [],
  "inline": [],
  "supertypes": []
}
```

Observations:

- `extras` seems autogenerated to represent whitespace.
- `delim` which was used in `grammar.js` is still not present.
- How about the definition of list,

  ```js
  list: ($) => delim(PARENS_LEFT, repeat($._sexp), PARENS_RIGHT)`
  ```

  Can we now recover the `PARENS_...` part? Yes we can, in members of `list`:

  ```json
  "list": {
    "type": "SEQ",
    "members": [
      {
        "type": "STRING",
        "value": "("
      },
      {
        "type": "REPEAT",
        "content": {
          "type": "SYMBOL",
          "name": "_sexp"
        }
      },
      {
        "type": "STRING",
        "value": ")"
      }
    ]
  }
  ```

  So `node-types.json` is basically a summary of `grammar.json`, with all the
  'trivial' stuff removed.

  TODO: Check if it is always the case.

## corpus.txt

Now, we can actually see the parser in action by looking at the test corpus.

```sexp
================================================================================
atom
================================================================================

hello

--------------------------------------------------------------------------------

(sexp
  (atom))

================================================================================
empty
================================================================================

()

--------------------------------------------------------------------------------

(sexp
  (list))

================================================================================
ERROR
================================================================================

(ERROR ) what)

--------------------------------------------------------------------------------

(sexp (list (atom)) (ERROR (atom)))

================================================================================
MISSING
================================================================================

(MISSING

--------------------------------------------------------------------------------

(sexp (list (atom) (MISSING ")")))
``` 

We see that the quotes showing `UNEXPECTED` and `MISSING` tokens are missing
from the definition, as they are errors, but now we can easily even add them to
the spec of s-expressions if needed.

```javascript
  _sexp:  ($) => choice($.atom, $.list, $.string),
  string: ($) => choice(
    seq("'", /[^']*/,"'"),
    seq('"', /[^"]*/,'"'),
    /\d+/
  ),
```

```bash
================================================================================
UNEXPECTED
================================================================================

(source_file            
  (ERROR                
    (UNEXPECTED '\n'))) 

--------------------------------------------------------------------------------

(sexp
  (list
    (atom)
    (list
      (atom)
      (list
        (atom)
        (string)))))
```


<hr/>
